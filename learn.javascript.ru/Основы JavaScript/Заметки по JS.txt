// Переменные 
let message; // var or let вар старая херь
// имена _$a-z
// ; не забывай ебло


Константы
const myBirthday = '18.04.1982';
// Константы в верхнем регистре
/*Обычно мы используем буквы в верхнем регистре для констант, 
которые «жёстко закодированы». Или, другими словами, когда 
значение известно до выполнения скрипта и записывается 
непосредственно в код.*/
const age = someCode(BIRTHDAY);
const COLOR_RED = "#F00";


Типы данных

Число
let n = 123;
n = 12.345;
Числовой тип данных (number) представляет как целочисленные значения, 
так и числа с плавающей точкой.
Кроме обычных чисел, существуют так называемые «специальные числовые 
значения», которые относятся к этому типу данных: Infinity, -Infinity 
и NaN.
Infinity представляет собой математическую бесконечность ∞. 
Это особое значение, которое больше любого числа.
NaN означает вычислительную ошибку. Это результат неправильной или 
неопределённой математической операции

BigInt
// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;
Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать
 с целыми числами произвольной длины.

Строка
let str = "Привет";
let str2 = 'Одинарные кавычки тоже подойдут';
let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;

Булевый (логический) тип
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено

Значение «null»
let age = null;

Значение «undefined»
Специальное значение undefined также стоит особняком. 
Оно формирует тип из самого себя так же, как и null.
Оно означает, что «значение не было присвоено».

Объекты и символы
object (объект)  для более сложных структур данных.
symbol (символ) для уникальных идентификаторов.

Оператор typeof
Оператор typeof возвращает тип аргумента. Это полезно, 
когда мы хотим обрабатывать значения различных типов по-разному 
или просто хотим сделать проверку.


----------------------------------------------------------------------

Взаимодействие: alert, prompt, confirm

alert("Hello"); - небольшое окно с сообщением называется модальным окном

prompt(title, [default]); - модальное окно с текстом, 
полем для ввода текста и кнопками OK/Отмена.

let age = prompt('Сколько тебе лет?');
alert(`Тебе ${age} лет!`); 

confirm
confirm(question);
Функция confirm отображает модальное окно с текстом вопроса 
question и двумя кнопками: OK и Отмена.

let isBoss = confirm("Ты здесь главный?");
alert( isBoss ); // true, если нажата OK

----------------------------------------------------------------------

Преобразование типов

Строковое преобразование
String(value)

Численное преобразование
Number(value)

Логическое преобразование
Boolean(value)

----------------------------------------------------------------------

Условное ветвление: if, '?'

let year = prompt('В каком году была опубликована 
спецификация ECMAScript-2015?', '');
if (year == 2015) alert( 'Вы правы!' );
// or
if (year == 2015) {
  alert( "Правильно!" );
  alert( "Вы такой умный!" );
}
// else 
if (year == 2015) {
  alert( 'Да вы знаток!' );
} else {
  alert( 'А вот и неправильно!' ); // любое значение, кроме 2015
}
// else if
if (year < 2015) {
  alert( 'Это слишком рано...' );
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}

Условный оператор „?“
let result = условие ? значение1 : значение2;
Сначала вычисляется условие: если оно истинно, тогда 
возвращается значение1, в противном случае – значение2.

Несколько операторов „?“
let age = prompt('Возраст?', 18);
let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';

----------------------------------------------------------------------

Логические операторы

|| (ИЛИ), && (И) и ! (НЕ).

ИЛИ «||» находит первое истинное значение
result = value1 || value2 || value3;

И «&&» находит первое ложное значение
result = value1 && value2 && value3;

----------------------------------------------------------------------

Оператор объединения с null '??'
Результат выражения a ?? b будет следующим:

a, если значение a определено,
b, если значение a не определено.

----------------------------------------------------------------------

Циклы while и for
while (condition) {
  // код
  // также называемый "телом цикла"
}


do {
  // тело цикла
} while (condition);
Цикл сначала выполнит тело, а затем проверит условие condition,
 и пока его значение равно true, он будет выполняться снова и снова.

Цикл «for»
for (начало; условие; шаг) {
  // ... тело цикла ...
}

Прерывание цикла: «break»
Переход к следующей итерации: continue

----------------------------------------------------------------------

Конструкция "switch"
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}

Группировка «case»
  case 3: // (*) группируем оба case
  case 5:
    alert('Неправильно!');
    alert("Может вам посетить урок математики?");
    break;

----------------------------------------------------------------------

Функции
function имя(параметры) {
  ...тело...
}

Выбор имени функции
"get…" – возвращают значение,
"calc…" – что-то вычисляют,
"create…" – что-то создают,
"check…" – что-то проверяют и возвращают логическое значение, и т.д.

----------------------------------------------------------------------

Function Expression
let sayHi = function() {
  alert( "Привет" );
};

Функции-«колбэки»
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "Вы согласны." );
}

function showCancel() {
  alert( "Вы отменили выполнение." );
}

// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel);

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);
Если функция объявлена как отдельная инструкция в основном потоке кода, то это Function Declaration.
Если функция была создана как часть выражения, то считается, что эта функция объявлена при помощи Function Expression.
Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
Функции, объявленные при помощи Function Expression, создаются, только когда поток выполнения достигает их.

----------------------------------------------------------------------

Функции-стрелки, основы
let func = (arg1, arg2, ...argN) => expression
// это тоже самое что 
let func = function(arg1, arg2, ...argN) {
  return expression;
};

Многострочные стрелочные функции
let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // при фигурных скобках для возврата значения нужно явно вызвать return
};

alert( sum(1, 2) ); // 3

----------------------------------------------------------------------

Качество кода


Команда Debugger
Выполнение кода можно также приостановить с помощью команды debugger 
прямо изнутри самого кода

Логирование
Если нужно что-то вывести в консоль из кода, применяется функция 
console.log

----------------------------------------------------------------------

Объекты: основы
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"
let user = {     // объект
  name: "John",  // под ключом "name" хранится значение "John"
  age: 30        // под ключом "age" хранится значение 30
};

delete user.age;

Квадратные скобки
let user = {};

// присваивание значения свойству
user["likes birds"] = true;

// получение значения свойства
alert(user["likes birds"]); // true

// удаление свойства
delete user["likes birds"];

Вычисляемые свойства
let fruit = prompt("Какой фрукт купить?", "apple");

let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};

alert( bag.apple ); // 5, если fruit="apple"

Проверка существования свойства, оператор «in»
"key" in object
let user = { name: "John", age: 30 };
alert( "age" in user ); // true, user.age существует

Цикл «for…in»
or (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}

Чтобы получить доступ к свойству, мы можем использовать:

Запись через точку: obj.property.
Квадратные скобки obj["property"]. Квадратные скобки позволяют взять 
ключ из переменной, например, obj[varWithKey].

Клонирование и объединение объектов, Object.assign
let user = {
  name: "Иван",
  age: 30
};

let clone = {}; // новый пустой объект

// скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}

Для этого есть Object.assign
Object.assign(dest, [src1, src2, src3...])
let user = { name: "Иван" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "Иван", canView: true, canEdit: true }


let user = {
  name: "Иван",
  age: 30
};

let clone = Object.assign({}, user);

Вложенное клонирование
Мы можем реализовать глубокое клонирование, используя рекурсию. 
Или, чтобы не изобретать велосипед, использовать готовую реализацию —
 метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.

----------------------------------------------------------------------

Сборка мусора
Интерпретаторы JavaScript применяют множество оптимизаций, чтобы сборка мусора работала быстрее и не влияла на производительность.

Вот некоторые из оптимизаций:

Сборка по поколениям (Generational collection) – объекты делятся на «новые» и «старые». Многие объекты появляются, выполняют свою задачу и быстро умирают, их можно удалять более агрессивно. Те, которые живут достаточно долго, становятся «старыми» и проверяются реже.
Инкрементальная сборка (Incremental collection) – если объектов много, то обход всех ссылок и пометка достижимых объектов может занять значительное время и привести к видимым задержкам выполнения скрипта. Поэтому интерпретатор пытается организовать сборку мусора поэтапно. Этапы выполняются по отдельности один за другим. Это требует дополнительного учёта для отслеживания изменений между этапами, но зато теперь у нас есть много крошечных задержек вместо одной большой.
Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.

----------------------------------------------------------------------

Методы объекта, "this"
Примеры методов
let user = {
  name: "Джон",
  age: 30
};

user.sayHi = function() {
  alert("Привет!");
};

user.sayHi(); // Привет!

Ключевое слово «this» в методах
let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    // this - это "текущий объект"
    alert(this.name);
  }

};

user.sayHi(); // Джон

У стрелочных функций нет «this»
let user = {
  firstName: "Илья",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};



user.sayHi(); // Илья
У стрелочных функций нет «this»

----------------------------------------------------------------------

Конструкторы, создание объектов через "new"
Функция-конструктор
Функции-конструкторы являются обычными функциями. Но есть два соглашения:

Имя функции-конструктора должно начинаться с большой буквы.
Функция-конструктор должна вызываться при помощи оператора "new".

function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Вася");

alert(user.name); // Вася
alert(user.isAdmin); // false
Функции-конструкторы или просто конструкторы являются обычными функциями, именовать которые следует с заглавной буквы.
Конструкторы следует вызывать при помощи оператора new. Такой вызов создаёт пустой this в начале выполнения и возвращает заполненный в конце.

----------------------------------------------------------------------

Опциональная цепочка '?.'
let user = {}; // пользователь без свойства address

alert(user.address.street); // ошибка!

let user = {}; // пользователь без адреса

alert( user && user.address && user.address.street ); // undefined (без ошибки)

Опциональная цепочка
let user = {}; // пользователь без адреса

alert( user?.address?.street ); // undefined (без ошибки)

Синтаксис опциональной цепочки ?. имеет три формы:
obj?.prop – возвращает obj.prop, если существует obj, и undefined в противном случае.
obj?.[prop] – возвращает obj[prop], если существует obj, и undefined в противном случае.
obj.method?.() – вызывает obj.method(), если существует obj.method, в противном случае возвращает undefined.

----------------------------------------------------------------------

Тип данных Symbol
«Символ» представляет собой уникальный идентификатор.
При создании символу можно дать описание (также называемое имя), 
в основном использующееся для отладки кода:
// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");
Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны, то следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в качестве имени. Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

Символы имеют два основных варианта использования:

«Скрытые» свойства объектов. Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в for..in, так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.

Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.

Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.

----------------------------------------------------------------------

Преобразование объектов в примитивы
"string"
Для преобразования объекта к строке, когда операция ожидает 
получить строку, например alert:
// вывод
alert(obj);

// используем объект в качестве имени свойства
anotherObj[obj] = 123;

"number"
// явное преобразование
let num = Number(obj);

// математическое (исключая бинарный оператор "+")
let n = +obj; // унарный плюс
let delta = date1 - date2;

// сравнения больше/меньше
let greater = user1 > user2;

"default"
Происходит редко, когда оператор «не уверен», какой тип ожидать.
// бинарный плюс
let total = car1 + car2;

// obj == string/number/symbol
if (user == 1) { ... };

В процессе преобразования движок JavaScript пытается найти и вызвать три следующих метода объекта:

Вызывает obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует, и передаёт ему хинт.
Иначе, если хинт равен "string"
пытается вызвать obj.toString(), а если его нет, то obj.valueOf(), если он существует.
В случае, если хинт равен "number" или "default"
пытается вызвать obj.valueOf(), а если его нет, то obj.toString(), если он существует.

Symbol.toPrimitive
метод с таким названием (если есть) используется для всех преобразований:
obj[Symbol.toPrimitive] = function(hint) {
  // должен вернуть примитивное значение
  // hint равно чему-то одному из: "string", "number" или "default"
};

Методы toString/valueOf
Если нет метода Symbol.toPrimitive, движок JavaScript пытается найти 
эти методы и вызвать их следующим образом:
toString -> valueOf для хинта со значением «string».
valueOf -> toString – в ином случае.

----------------------------------------------------------------------

Типы данных

Числа
number
BigInt

Округление
Math.floor
Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
Math.ceil
Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
Math.round
Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
Math.trunc (не поддерживается в Internet Explorer)
Производит удаление дробной части без округления: 3.1 становится 3
 
Метод toFixed(n) округляет число до n знаков после запятой и возвращает 
строковое представление результата.
Округляет значение до ближайшего числа, как в большую, так и в меньшую 
сторону, аналогично методу Math.round
let num = 12.36;
alert( num.toFixed(1) ); // "12.4"

Проверка: isFinite и isNaN
Infinity (и -Infinity) — особенное численное значение, которое ведёт себя
 в точности как математическая бесконечность ∞.
NaN представляет ошибку.

parseInt и parseFloat
Парсим строку в int и float
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

Math.random()
Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 
(но не включая 1)

Math.max(a, b, c...) / Math.min(a, b, c...)
Возвращает наибольшее/наименьшее число из перечисленных аргументов.

Math.pow(n, power)
Возвращает число n, возведённое в степень power

Math Documentation 
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math

----------------------------------------------------------------------

Строки
function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.

Длина строки
length

Доступ к символам
// получаем первый символ
alert( str[0] ); // H
alert( str.charAt(0) ); // H

Строки неизменяемы
let str = 'Hi';

str[0] = 'h'; // ошибка
alert( str[0] ); // не работает
str = 'h' + str[1]; // заменяем строку

Изменение регистра
toLowerCase() и toUpperCase()

Поиск подстроки
str.indexOf(substr, pos)
let str = 'Widget with id';
alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру
alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)


includes, startsWith, endsWith
alert( "Widget with id".includes("Widget") ); // true
alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"

Получение подстроки - substring, substr и slice
slice
let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
alert( str.slice(0, 5) );
alert( str.slice(2) ); // ringify, с позиции 2 и до конца

str.substring(start [, end])
// для substring эти два примера — одинаковы
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

str.substr(start [, length])
// ring, получаем 4 символа, начиная с позиции 2
alert( str.substr(2, 4) );


str.codePointAt(pos)
Возвращает код для символа, находящегося на позиции pos

String.fromCodePoint(code)
Создаёт символ по его коду code

str.trim() — убирает пробелы в начале и конце строки.
str.repeat(n) — повторяет строку n раз

Справочник по строкам 
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String

----------------------------------------------------------------------

Массивы
let arr = new Array();
let arr = [];

Методы pop/push, shift/unshift
push добавляет элемент в конец.
shift удаляет элемент в начале, сдвигая очередь, так что второй 
элемент становится первым.
pop удаляет последний элемент.
unshift Добавляет элемент в начало массива

toString
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true

----------------------------------------------------------------------

Методы массивов

Для добавления/удаления элементов:

push (...items) – добавляет элементы в конец,
pop() – извлекает элемент с конца,
shift() – извлекает элемент с начала,
unshift(...items) – добавляет элементы в начало.
splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
Для поиска среди элементов:

indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
findIndex похож на find, но возвращает индекс вместо значения.
Для перебора элементов:

forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
Для преобразования массива:

map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
sort(func) – сортирует массив «на месте», а потом возвращает его.
reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
split/join – преобразует строку в массив и обратно.
reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
Дополнительно:

Array.isArray(arr) проверяет, является ли arr массивом.

----------------------------------------------------------------------

Перебираемые объекты

Технически итерируемые объекты должны иметь метод Symbol.iterator.
Результат вызова obj[Symbol.iterator] называется итератором. Он управляет процессом итерации.
Итератор должен иметь метод next(), который возвращает объект {done: Boolean, value: any}, где done:true сигнализирует об окончании процесса итерации, в противном случае value – следующее значение.
Метод Symbol.iterator автоматически вызывается циклом for..of, но можно вызвать его и напрямую.
Встроенные итерируемые объекты, такие как строки или массивы, также реализуют метод Symbol.iterator.
Строковый итератор знает про суррогатные пары.

----------------------------------------------------------------------

Map и Set
Map – это коллекция ключ/значение, как и Object. Но основное 
отличие в том, что Map позволяет использовать ключи любого типа.
new Map() – создаёт коллекцию.
map.set(key, value) – записывает по ключу key значение value.
map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
map.delete(key) – удаляет элемент по ключу key.
map.clear() – очищает коллекцию от всех элементов.
map.size – возвращает текущее количество элементов.

Перебор Map
map.keys() – возвращает итерируемый объект по ключам,
map.values() – возвращает итерируемый объект по значениям,
map.entries() – возвращает итерируемый объект по парам вида 
[ключ, значение], этот вариант используется по умолчанию в for..of.

Object.entries: Map из Object
let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));


Object.fromEntries: Object из Map
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// now prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2

Set
Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:

new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
set.clear() – удаляет все имеющиеся значения.
set.size – возвращает количество элементов в множестве.
set.values() – возвращает перебираемый объект для значений,
set.keys() – то же самое, что и set.values(), присутствует для обратной совместимости с Map,
set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.

----------------------------------------------------------------------

WeakMap и WeakSet
WeakMap – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.

WeakSet – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. Возможны только операции на отдельном элементе коллекции.

WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически.

----------------------------------------------------------------------





