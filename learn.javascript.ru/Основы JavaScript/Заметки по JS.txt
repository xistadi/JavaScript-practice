// Переменные 
let message; // var or let вар старая херь
// имена _$a-z
// ; не забывай ебло


Константы
const myBirthday = '18.04.1982';
// Константы в верхнем регистре
/*Обычно мы используем буквы в верхнем регистре для констант, 
которые «жёстко закодированы». Или, другими словами, когда 
значение известно до выполнения скрипта и записывается 
непосредственно в код.*/
const age = someCode(BIRTHDAY);
const COLOR_RED = "#F00";


Типы данных

Число
let n = 123;
n = 12.345;
Числовой тип данных (number) представляет как целочисленные значения, 
так и числа с плавающей точкой.
Кроме обычных чисел, существуют так называемые «специальные числовые 
значения», которые относятся к этому типу данных: Infinity, -Infinity 
и NaN.
Infinity представляет собой математическую бесконечность ∞. 
Это особое значение, которое больше любого числа.
NaN означает вычислительную ошибку. Это результат неправильной или 
неопределённой математической операции

BigInt
// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;
Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать
 с целыми числами произвольной длины.

Строка
let str = "Привет";
let str2 = 'Одинарные кавычки тоже подойдут';
let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;

Булевый (логический) тип
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено

Значение «null»
let age = null;

Значение «undefined»
Специальное значение undefined также стоит особняком. 
Оно формирует тип из самого себя так же, как и null.
Оно означает, что «значение не было присвоено».

Объекты и символы
object (объект)  для более сложных структур данных.
symbol (символ) для уникальных идентификаторов.

Оператор typeof
Оператор typeof возвращает тип аргумента. Это полезно, 
когда мы хотим обрабатывать значения различных типов по-разному 
или просто хотим сделать проверку.


----------------------------------------------------------------------

Взаимодействие: alert, prompt, confirm

alert("Hello"); - небольшое окно с сообщением называется модальным окном

prompt(title, [default]); - модальное окно с текстом, 
полем для ввода текста и кнопками OK/Отмена.

let age = prompt('Сколько тебе лет?');
alert(`Тебе ${age} лет!`); 

confirm
confirm(question);
Функция confirm отображает модальное окно с текстом вопроса 
question и двумя кнопками: OK и Отмена.

let isBoss = confirm("Ты здесь главный?");
alert( isBoss ); // true, если нажата OK

----------------------------------------------------------------------

Преобразование типов

Строковое преобразование
String(value)

Численное преобразование
Number(value)

Логическое преобразование
Boolean(value)

----------------------------------------------------------------------

Условное ветвление: if, '?'

let year = prompt('В каком году была опубликована 
спецификация ECMAScript-2015?', '');
if (year == 2015) alert( 'Вы правы!' );
// or
if (year == 2015) {
  alert( "Правильно!" );
  alert( "Вы такой умный!" );
}
// else 
if (year == 2015) {
  alert( 'Да вы знаток!' );
} else {
  alert( 'А вот и неправильно!' ); // любое значение, кроме 2015
}
// else if
if (year < 2015) {
  alert( 'Это слишком рано...' );
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}

Условный оператор „?“
let result = условие ? значение1 : значение2;
Сначала вычисляется условие: если оно истинно, тогда 
возвращается значение1, в противном случае – значение2.

Несколько операторов „?“
let age = prompt('Возраст?', 18);
let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';

----------------------------------------------------------------------

Логические операторы

|| (ИЛИ), && (И) и ! (НЕ).

ИЛИ «||» находит первое истинное значение
result = value1 || value2 || value3;

И «&&» находит первое ложное значение
result = value1 && value2 && value3;

----------------------------------------------------------------------

Оператор объединения с null '??'
Результат выражения a ?? b будет следующим:

a, если значение a определено,
b, если значение a не определено.

----------------------------------------------------------------------

Циклы while и for
while (condition) {
  // код
  // также называемый "телом цикла"
}


do {
  // тело цикла
} while (condition);
Цикл сначала выполнит тело, а затем проверит условие condition,
 и пока его значение равно true, он будет выполняться снова и снова.

Цикл «for»
for (начало; условие; шаг) {
  // ... тело цикла ...
}

Прерывание цикла: «break»
Переход к следующей итерации: continue

----------------------------------------------------------------------

Конструкция "switch"
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}

Группировка «case»
  case 3: // (*) группируем оба case
  case 5:
    alert('Неправильно!');
    alert("Может вам посетить урок математики?");
    break;

----------------------------------------------------------------------

Функции
function имя(параметры) {
  ...тело...
}

Выбор имени функции
"get…" – возвращают значение,
"calc…" – что-то вычисляют,
"create…" – что-то создают,
"check…" – что-то проверяют и возвращают логическое значение, и т.д.

----------------------------------------------------------------------

Function Expression
let sayHi = function() {
  alert( "Привет" );
};

Функции-«колбэки»
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "Вы согласны." );
}

function showCancel() {
  alert( "Вы отменили выполнение." );
}

// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel);

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);
Если функция объявлена как отдельная инструкция в основном потоке кода, то это Function Declaration.
Если функция была создана как часть выражения, то считается, что эта функция объявлена при помощи Function Expression.
Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
Функции, объявленные при помощи Function Expression, создаются, только когда поток выполнения достигает их.

----------------------------------------------------------------------

Функции-стрелки, основы
let func = (arg1, arg2, ...argN) => expression
// это тоже самое что 
let func = function(arg1, arg2, ...argN) {
  return expression;
};

Многострочные стрелочные функции
let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // при фигурных скобках для возврата значения нужно явно вызвать return
};

alert( sum(1, 2) ); // 3

----------------------------------------------------------------------

Качество кода


Команда Debugger
Выполнение кода можно также приостановить с помощью команды debugger 
прямо изнутри самого кода

Логирование
Если нужно что-то вывести в консоль из кода, применяется функция 
console.log

----------------------------------------------------------------------

Объекты: основы
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"
let user = {     // объект
  name: "John",  // под ключом "name" хранится значение "John"
  age: 30        // под ключом "age" хранится значение 30
};

delete user.age;

Квадратные скобки
let user = {};

// присваивание значения свойству
user["likes birds"] = true;

// получение значения свойства
alert(user["likes birds"]); // true

// удаление свойства
delete user["likes birds"];

Вычисляемые свойства
let fruit = prompt("Какой фрукт купить?", "apple");

let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};

alert( bag.apple ); // 5, если fruit="apple"

Проверка существования свойства, оператор «in»
"key" in object
let user = { name: "John", age: 30 };
alert( "age" in user ); // true, user.age существует

Цикл «for…in»
or (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}

Чтобы получить доступ к свойству, мы можем использовать:

Запись через точку: obj.property.
Квадратные скобки obj["property"]. Квадратные скобки позволяют взять 
ключ из переменной, например, obj[varWithKey].

Клонирование и объединение объектов, Object.assign
let user = {
  name: "Иван",
  age: 30
};

let clone = {}; // новый пустой объект

// скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}

Для этого есть Object.assign
Object.assign(dest, [src1, src2, src3...])
let user = { name: "Иван" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "Иван", canView: true, canEdit: true }


let user = {
  name: "Иван",
  age: 30
};

let clone = Object.assign({}, user);

Вложенное клонирование
Мы можем реализовать глубокое клонирование, используя рекурсию. 
Или, чтобы не изобретать велосипед, использовать готовую реализацию —
 метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.

----------------------------------------------------------------------

Сборка мусора
Интерпретаторы JavaScript применяют множество оптимизаций, чтобы сборка мусора работала быстрее и не влияла на производительность.

Вот некоторые из оптимизаций:

Сборка по поколениям (Generational collection) – объекты делятся на «новые» и «старые». Многие объекты появляются, выполняют свою задачу и быстро умирают, их можно удалять более агрессивно. Те, которые живут достаточно долго, становятся «старыми» и проверяются реже.
Инкрементальная сборка (Incremental collection) – если объектов много, то обход всех ссылок и пометка достижимых объектов может занять значительное время и привести к видимым задержкам выполнения скрипта. Поэтому интерпретатор пытается организовать сборку мусора поэтапно. Этапы выполняются по отдельности один за другим. Это требует дополнительного учёта для отслеживания изменений между этапами, но зато теперь у нас есть много крошечных задержек вместо одной большой.
Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.

----------------------------------------------------------------------

Методы объекта, "this"
Примеры методов
let user = {
  name: "Джон",
  age: 30
};

user.sayHi = function() {
  alert("Привет!");
};

user.sayHi(); // Привет!

Ключевое слово «this» в методах
let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    // this - это "текущий объект"
    alert(this.name);
  }

};

user.sayHi(); // Джон

У стрелочных функций нет «this»
let user = {
  firstName: "Илья",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};



user.sayHi(); // Илья
У стрелочных функций нет «this»

----------------------------------------------------------------------

Конструкторы, создание объектов через "new"
Функция-конструктор
Функции-конструкторы являются обычными функциями. Но есть два соглашения:

Имя функции-конструктора должно начинаться с большой буквы.
Функция-конструктор должна вызываться при помощи оператора "new".

function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Вася");

alert(user.name); // Вася
alert(user.isAdmin); // false
Функции-конструкторы или просто конструкторы являются обычными функциями, именовать которые следует с заглавной буквы.
Конструкторы следует вызывать при помощи оператора new. Такой вызов создаёт пустой this в начале выполнения и возвращает заполненный в конце.

----------------------------------------------------------------------

Опциональная цепочка '?.'
let user = {}; // пользователь без свойства address

alert(user.address.street); // ошибка!

let user = {}; // пользователь без адреса

alert( user && user.address && user.address.street ); // undefined (без ошибки)

Опциональная цепочка
let user = {}; // пользователь без адреса

alert( user?.address?.street ); // undefined (без ошибки)

Синтаксис опциональной цепочки ?. имеет три формы:
obj?.prop – возвращает obj.prop, если существует obj, и undefined в противном случае.
obj?.[prop] – возвращает obj[prop], если существует obj, и undefined в противном случае.
obj.method?.() – вызывает obj.method(), если существует obj.method, в противном случае возвращает undefined.

----------------------------------------------------------------------

Тип данных Symbol
«Символ» представляет собой уникальный идентификатор.
При создании символу можно дать описание (также называемое имя), 
в основном использующееся для отладки кода:
// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");
Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны, то следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в качестве имени. Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

Символы имеют два основных варианта использования:

«Скрытые» свойства объектов. Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в for..in, так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.

Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.

Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.

----------------------------------------------------------------------

Преобразование объектов в примитивы
"string"
Для преобразования объекта к строке, когда операция ожидает 
получить строку, например alert:
// вывод
alert(obj);

// используем объект в качестве имени свойства
anotherObj[obj] = 123;

"number"
// явное преобразование
let num = Number(obj);

// математическое (исключая бинарный оператор "+")
let n = +obj; // унарный плюс
let delta = date1 - date2;

// сравнения больше/меньше
let greater = user1 > user2;

"default"
Происходит редко, когда оператор «не уверен», какой тип ожидать.
// бинарный плюс
let total = car1 + car2;

// obj == string/number/symbol
if (user == 1) { ... };

В процессе преобразования движок JavaScript пытается найти и вызвать три следующих метода объекта:

Вызывает obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует, и передаёт ему хинт.
Иначе, если хинт равен "string"
пытается вызвать obj.toString(), а если его нет, то obj.valueOf(), если он существует.
В случае, если хинт равен "number" или "default"
пытается вызвать obj.valueOf(), а если его нет, то obj.toString(), если он существует.

Symbol.toPrimitive
метод с таким названием (если есть) используется для всех преобразований:
obj[Symbol.toPrimitive] = function(hint) {
  // должен вернуть примитивное значение
  // hint равно чему-то одному из: "string", "number" или "default"
};

Методы toString/valueOf
Если нет метода Symbol.toPrimitive, движок JavaScript пытается найти 
эти методы и вызвать их следующим образом:
toString -> valueOf для хинта со значением «string».
valueOf -> toString – в ином случае.

----------------------------------------------------------------------

Типы данных

